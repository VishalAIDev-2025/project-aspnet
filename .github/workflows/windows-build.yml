name: Build ASP.NET Web App

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build:
    runs-on: windows-latest

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Setup NuGet
        uses: nuget/setup-nuget@v1

      - name: Restore Packages
        shell: powershell
        run: nuget restore "SampleWebApplication.sln"

      - name: Locate MSBuild
        id: locate-msbuild
        shell: powershell
        run: |
          Write-Host "Locating MSBuild..."
          $msbuild = $null
          $vswherePath = Join-Path $env:ProgramFiles 'Microsoft Visual Studio\Installer\vswhere.exe'
          if (Test-Path $vswherePath) {
            try {
              $installPath = & $vswherePath -latest -products * -requires Microsoft.Component.MSBuild -property installationPath 2>$null
              if ($installPath) {
                $candidate = Join-Path $installPath 'MSBuild\Current\Bin\MSBuild.exe'
                if (Test-Path $candidate) { $msbuild = $candidate }
              }
            } catch { Write-Host "vswhere invocation failed or returned nothing." }
          }
          if (-not $msbuild) {
            $searchRoots = @(
              'C:\Program Files\Microsoft Visual Studio',
              'C:\Program Files (x86)\Microsoft Visual Studio',
              'C:\Program Files (x86)\MSBuild',
              'C:\Program Files\Microsoft Visual Studio\2022'
            )
            foreach ($root in $searchRoots) {
              if (Test-Path $root) {
                try {
                  $found = Get-ChildItem -Path $root -Filter MSBuild.exe -Recurse -ErrorAction SilentlyContinue -Force | Select-Object -First 1
                  if ($found -and $found.FullName) { $msbuild = $found.FullName; break }
                } catch { Write-Host "Search under $root failed or was skipped." }
              }
            }
          }
          if (-not $msbuild) {
            $fallbacks = @(
              'C:\Program Files\Microsoft Visual Studio\2022\BuildTools\MSBuild\Current\Bin\MSBuild.exe',
              'C:\Program Files\Microsoft Visual Studio\2022\Professional\MSBuild\Current\Bin\MSBuild.exe',
              'C:\Program Files\Microsoft Visual Studio\2022\Enterprise\MSBuild\Current\Bin\MSBuild.exe',
              'C:\Program Files (x86)\MSBuild\14.0\Bin\MSBuild.exe'
            )
            foreach ($f in $fallbacks) { if (Test-Path $f) { $msbuild = $f; break } }
          }
          if (-not $msbuild) {
            Write-Host "ERROR: MSBuild.exe not found on this runner."
            if (Test-Path 'C:\Program Files\Microsoft Visual Studio') {
              Get-ChildItem 'C:\Program Files\Microsoft Visual Studio' -Force | ForEach-Object { Write-Host $_.FullName }
            } else {
              Write-Host "C:\Program Files\Microsoft Visual Studio does not exist on this runner."
            }
            exit 1
          }
          Write-Host "MSBuild found at: $msbuild"
          Add-Content -Path $env:GITHUB_ENV -Value ('MSBUILD_PATH=' + $msbuild)

      - name: Build Solution
        shell: powershell
        run: |
          Write-Host "Building solution..."
          & "$env:MSBUILD_PATH" "SampleWebApplication.sln" /p:Configuration=Release

      - name: Try Package Publish (creates PackageTmp)
        shell: powershell
        run: |
          Write-Host "Attempting MSBuild Package publish (PackageTmp)..."
          & "$env:MSBUILD_PATH" ".\SampleWebApplication\SampleWebApplication.csproj" /p:Configuration=Release /p:DeployOnBuild=true /p:WebPublishMethod=Package /p:PackageAsSingleFile=false /p:SkipInvalidConfigurations=true
          Write-Host "Package publish step finished. (Check logs above for errors/warnings.)"

      - name: Ensure publish output (fallback to FileSystem publish if PackageTmp missing)
        shell: powershell
        run: |
          function Run-Robocopy {
            param($src, $dst)
            Write-Host "Robocopy $src -> $dst"
            robocopy $src $dst /E | Out-Null
            $rc = $LASTEXITCODE
            Write-Host "robocopy exit code: $rc"
            # robocopy codes: 0..7 = success/warning, >=8 = failure
            if ($rc -ge 8) {
              Write-Host "robocopy reported a fatal error (exit code $rc)."
              exit $rc
            } else {
              Write-Host "robocopy completed (acceptable exit code $rc)."
            }
          }

          $packageTmp = ".\SampleWebApplication\obj\Release\Package\PackageTmp"
          $publishDir = "publish"

          if (Test-Path $packageTmp) {
            Write-Host "Found PackageTmp at $packageTmp - using it as publish source."
            if (Test-Path $publishDir) { Remove-Item $publishDir -Recurse -Force }
            New-Item -ItemType Directory -Path $publishDir | Out-Null
            Run-Robocopy $packageTmp $publishDir
          } else {
            Write-Host "PackageTmp not found. Attempting FileSystem publish directly to '$publishDir' using MSBuild..."
            if (Test-Path $publishDir) { Remove-Item $publishDir -Recurse -Force }
            # Try FileSystem publish
            & "$env:MSBUILD_PATH" ".\SampleWebApplication\SampleWebApplication.csproj" /p:Configuration=Release /p:DeployOnBuild=true /p:WebPublishMethod=FileSystem /p:publishUrl=$publishDir /p:SkipInvalidConfigurations=true

            if (Test-Path $publishDir) {
              Write-Host "FileSystem publish succeeded; publish folder created at $publishDir"
            } else {
              Write-Host "FileSystem publish did not create $publishDir. Falling back to copying bin and content if available..."
              $binDir = ".\SampleWebApplication\bin\Release"
              if (Test-Path $binDir) {
                New-Item -ItemType Directory -Path $publishDir | Out-Null
                Run-Robocopy $binDir (Join-Path $publishDir "bin")
              }
              $commonFolders = @("Views","Content","Scripts","assets","App_Data","fonts")
              foreach ($f in $commonFolders) {
                $src = Join-Path ".\SampleWebApplication" $f
                if (Test-Path $src) {
                  Run-Robocopy $src (Join-Path $publishDir $f)
                }
              }
            }
          }

          # Final check
          if (!(Test-Path $publishDir) -or ((Get-ChildItem $publishDir -Recurse | Measure-Object).Count -eq 0)) {
            Write-Host "ERROR: No publish output found after all attempts."
            Write-Host "Debug listing of SampleWebApplication folders (depth 2):"
            Get-ChildItem ".\SampleWebApplication" -Force -Recurse -Depth 2 | ForEach-Object { Write-Host $_.FullName }
            exit 1
          } else {
            Write-Host "Publish files ready in folder: $publishDir"
            Get-ChildItem $publishDir -Recurse | Select-Object FullName, Length | ForEach-Object { Write-Host $_.FullName }
          }

      - name: Create Artifact ZIP
        shell: powershell
        run: |
          if (Test-Path "publish.zip") { Remove-Item "publish.zip" -Force }
          # Force overwrite if exists
          Compress-Archive -Path (Join-Path (Get-Item publish).FullName '*') -DestinationPath publish.zip -Force
          Write-Host "publish.zip created."

      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-output
          path: publish.zip
